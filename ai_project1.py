# -*- coding: utf-8 -*-
"""AI_Project1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11VoYqviZiXxb_ssKfn6fzCCKUZqp7EeU
"""

final_moves_opti = []
final_moves_cowan = []
final_moves_effi = []

import pprint
# ship generation
# ship size DxD
D:int = 15
# representation of states on the ship
open = 0
blocked = 1
dead_end = 2
#open a random interior cell

ship = [[1 for _ in range(D)] for _ in range(D)]
random_i, random_j = random.randint(0, D -1), random.randint(0, D -1)
ship[random_i][random_j] = open
# iteratively open blocked cells with exactly one open neighbour
def exactly_one_open_neighbor(i :int, j :int, deadend=False) -> bool:
  count = 0
  if (i - 1) >= 0 and ship[i - 1][j] == open:
    count+=1
  if (i + 1) < D and ship[i + 1][j] == open:
    count+=1
  if (j + 1) < D and ship[i][j + 1] == open:
    count+=1
  if (j - 1) >= 0 and ship[i][j - 1] == open:
    count+=1
  if deadend:
    return count == 1
  return ship[i][j] == 1 and count == 1

while True:
  blocked_cells_with_exactly_one_open_neighbor = []
  for i in range(D):
    for j in range(D):
      if exactly_one_open_neighbor(i, j):
        blocked_cells_with_exactly_one_open_neighbor.append((i,j))
  # pprint.pprint(blocked_cells_with_exactly_one_neighbor)

  if len(blocked_cells_with_exactly_one_open_neighbor) < 1:
    break
  random_blocked_cell = random.randint(0, len(blocked_cells_with_exactly_one_open_neighbor) - 1)

  ship[blocked_cells_with_exactly_one_open_neighbor[random_blocked_cell][0]][blocked_cells_with_exactly_one_open_neighbor[random_blocked_cell][1]] = open
  # print(f"opening the cell {blocked_cells_with_exactly_one_open_neighbor[random_blocked_cell][0]}, {blocked_cells_with_exactly_one_open_neighbor[random_blocked_cell][1]}")

deadends = []
def id_deadends():
  for i in range(D):
    for j in range(D):
      if ship[i][j] == open:
        if exactly_one_open_neighbor(i, j, True):
          # ship[i][j] = dead_end
          deadends.append((i,j))

id_deadends()
# pprint.pprint(ship)

count = 0
for de in deadends:
  valid_neighbors = []
  def find_valid_neighbors(i, j):
    if (i - 1) >= 0 and ship[i - 1][j] == blocked:
      valid_neighbors.append((i - 1,j))
    if (i + 1) < D and ship[i + 1][j] == blocked:
      valid_neighbors.append((i + 1,j))
    if (j - 1) >= 0 and ship[i][j - 1] == blocked:
      valid_neighbors.append((i,j - 1))
    if (j + 1) < D and ship[i][j + 1] == blocked:
      valid_neighbors.append((i,j + 1))

  find_valid_neighbors(de[0], de[1])
  # print(valid_neighbors)
  if len(valid_neighbors) == 0:
    continue
  neigh_choice = random.randint(0, len(valid_neighbors) - 1)
  ship[valid_neighbors[neigh_choice][0]][valid_neighbors[neigh_choice][1]] = open
  count += 1
  if count >=len(deadends)//2:
    break

deadends = []
id_deadends()
pprint.pprint(ship)
if(deadends==0):
    print("no deadends")
else:
  pprint.pprint(deadends)
open_cells = sum(row.count(open) for row in ship)
print(f"Number of open cells: {open_cells}")
closed_cells = sum(row.count(blocked) for row in ship)
print(f"Number of blocked cells: {closed_cells}")

# Helper functions
from queue import PriorityQueue
# Returns path from start to goal
def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    path.reverse()
    return path

def get_neighbors(node, grid):
    x, y = node
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # up, down, left, right
    neighbors = []

    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != blocked:
            neighbors.append((nx, ny))

    return neighbors
# A* along with heuristic(manhattan distance)
def manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star(start, goal):
    open_set = PriorityQueue()
    open_set.put((0, start))
    came_from = {}
    g_score = {start: 0}

    while not open_set.empty():
        _, current = open_set.get()

        if current == goal:
            return reconstruct_path(came_from, current)

        for neighbor in get_neighbors(current, ship):  # Uses the ship from Cell 1
            tentative_g = g_score[current] + 1

            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                g_score[neighbor] = tentative_g
                f_score = tentative_g + manhattan(neighbor, goal)
                open_set.put((f_score, neighbor))
                came_from[neighbor] = current

    return None  # No path found

def get_moves_from_path(start_pos, path):
    """Convert a path to a sequence of moves"""
    moves = []
    current = start_pos
    for next_pos in path[1:]:  # Skip the first position (current position)
        if next_pos[0] == current[0] - 1:
            moves.append("UP")
        elif next_pos[0] == current[0] + 1:
            moves.append("DOWN")
        elif next_pos[1] == current[1] - 1:
            moves.append("LEFT")
        elif next_pos[1] == current[1] + 1:
            moves.append("RIGHT")
        current = next_pos
    return moves
# Find all open cells=>possible bot locations
def find_pos_bot_loc():

    possible_locations = []
    for i in range(len(ship)):
        for j in range(len(ship[0])):
            if ship[i][j] == open:
                possible_locations.append((i, j))
    return possible_locations
# perform 1 move from a position(keep in mind the blocked cells)
def simulate_single_move(position, move, ship_grid):

    x, y = position
    grid_size = len(ship_grid)

    if move == "UP" and x > 0 and ship_grid[x-1][y] == open:
        return (x-1, y)
    elif move == "DOWN" and x < grid_size-1 and ship_grid[x+1][y] == open:
        return (x+1, y)
    elif move == "LEFT" and y > 0 and ship_grid[x][y-1] == open:
        return (x, y-1)
    elif move == "RIGHT" and y < grid_size-1 and ship_grid[x][y+1] == open:
        return (x, y+1)
    else:
        # If move is blocked, stay in current position
        return position

# Initialize possible bot locations using the ship from Cell 1
possible_bot_locations = find_pos_bot_loc()
print(f"Using ship from Cell 1: {len(ship)}x{len(ship)}")
print(f"Possible bot locations: {len(possible_bot_locations)}")



#  Cowan's baseline  Strategy
import time

def cowans_strategy(ship, possible_bot_locations, deadends):

    if len(possible_bot_locations) == 1:
        return 0, []  # Already localized

    copy_pos_bot_loc = possible_bot_locations.copy()
    total_moves = 0
    move_sequence = []

    # Pick a dead end at random as target
    if not deadends:
        # If no dead ends, pick any open cell
        target = random.choice(possible_bot_locations)
    else:
        random_de = random.randint(0, len(deadends) - 1)
        target = deadends[random_de]

    print(f"Target: {target}")
    print(f"Initial possible locations: {len(copy_pos_bot_loc)}")

    while len(copy_pos_bot_loc) > 1:
        # Pick a location the bot might currently be in
        random_loc = random.randint(0, len(copy_pos_bot_loc) - 1)
        current_bot_loc = copy_pos_bot_loc[random_loc]

        # Plan shortest path from that location to target
        path = a_star(current_bot_loc, target)

        if not path:
            # If no path exists, pick new target
            if deadends:
                target = random.choice(deadends)
            else:
                target = random.choice(copy_pos_bot_loc)
            print(f"New target (no path): {target}")
            continue

        # Convert path to moves
        moves = []
        current_pos = current_bot_loc
        for next_pos in path[1:]:
            if next_pos[0] == current_pos[0] - 1:
                moves.append("UP")
            elif next_pos[0] == current_pos[0] + 1:
                moves.append("DOWN")
            elif next_pos[1] == current_pos[1] - 1:
                moves.append("LEFT")
            elif next_pos[1] == current_pos[1] + 1:
                moves.append("RIGHT")
            current_pos = next_pos

        print(f"Moving bot from {current_bot_loc} to target with {len(moves)} moves")

        # Execute moves on all possible bot locations
        for move in moves:
            new_positions = set()

            for pos in copy_pos_bot_loc:
                new_pos = simulate_single_move(pos, move, ship)
                new_positions.add(new_pos)

            copy_pos_bot_loc = list(new_positions)
            total_moves += 1
            move_sequence.append(move)

            print(f"After {move}: {len(copy_pos_bot_loc)} possible locations")

            # Check if we've localized
            if len(copy_pos_bot_loc) == 1:
                break

        # Check termination condition
        if len(copy_pos_bot_loc) == 1:
            break

        # If stuck (no reduction)->try new target
        if len(moves) == 0:
            if deadends:
                target = random.choice(deadends)
            else:
                target = random.choice(copy_pos_bot_loc)
            print(f"New target (stuck): {target}")

    print(f"Final localized position: {copy_pos_bot_loc[0] if copy_pos_bot_loc else 'None'}")
    return total_moves, move_sequence
# Perform  a single move from a position, considering any blocked cells
def simulate_single_move(position, move, ship):

    x, y = position
    D = len(ship)

    if move == "UP" and x > 0 and ship[x-1][y] == open:
        return (x-1, y)
    elif move == "DOWN" and x < D-1 and ship[x+1][y] == open:
        return (x+1, y)
    elif move == "LEFT" and y > 0 and ship[x][y-1] == open:
        return (x, y-1)
    elif move == "RIGHT" and y < D-1 and ship[x][y+1] == open:
        return (x, y+1)
    else:
        # If move is blocked, stay in current position
        return position

def run_baseline_strat(ship):
  print("Baseline Strategy...")
  start_time = time.time()

  # Get possible bot locations and deadends
  possible_bot_locations = []
  for i in range(D):
      for j in range(D):
          if ship[i][j] == open:
              possible_bot_locations.append((i, j))

  deadends = []
  for i in range(D):
      for j in range(D):
          if ship[i][j] == open:
              count = 0
              if i > 0 and ship[i-1][j] == open: count += 1
              if i < D-1 and ship[i+1][j] == open: count += 1
              if j > 0 and ship[i][j-1] == open: count += 1
              if j < D-1 and ship[i][j+1] == open: count += 1
              if count == 1:
                  deadends.append((i, j))

  print(f"Initial possible locations: {len(possible_bot_locations)}")
  print(f"Dead ends: {len(deadends)}")

  total_moves, move_sequence = cowans_strategy(ship, possible_bot_locations, deadends)
  end_time = time.time()
  final_moves_cowan.append((D, total_moves, (end_time - start_time)*100))
  print(f"\nResults:")
  print(f"Total moves: {total_moves}")
  print(f"Execution time: {(end_time - start_time)*100:.4f} seconds")

run_baseline_strat(ship)



# Cell 5: Efficiency Strategy
def efficiency_strategy(ship, possible_bot_locations, max_time=30):

    import time
    import random
    start_time = time.time()

    current_state = set(possible_bot_locations)
    path = []

    print(f"Starting efficiency strategy on {len(ship)}x{len(ship)} ship")
    print(f"Initial possible locations: {len(current_state)}")

    while len(current_state) > 1 and (time.time() - start_time) < max_time:
        # Pick random move
        move = random.choice(["UP", "DOWN", "LEFT", "RIGHT"])

        # Apply move to all positions
        new_state = set()
        for pos in current_state:
            new_pos = simulate_single_move(pos, move, ship)
            new_state.add(new_pos)

        current_state = new_state
        path.append(move)

        # Check if localized
        if len(current_state) == 1:
            print(f"Solution found!")
            break

    computation_time = time.time() - start_time
    print(f"Efficiency strategy completed")
    print(f"Total moves: {len(path)}")
    print(f"Final locations: {len(current_state)}")
    print(f"Time: {computation_time:.2f}s")

    return len(path), path, computation_time

def run_efficiency_on_ship(ship_grid, max_time=30):

    # Get all possible locations from the ship
    possible_locations = []
    for i in range(len(ship_grid)):
        for j in range(len(ship_grid)):
            if ship_grid[i][j] == 0:
                possible_locations.append((i, j))

    print(f"Ship size: {len(ship_grid)}x{len(ship_grid)}")
    print(f"Open cells: {len(possible_locations)}")

    # Run efficiency strategy
    moves, path, comp_time = efficiency_strategy(
        ship_grid,
        possible_locations,
        max_time=max_time
    )

    final_moves_effi.append((D, moves, comp_time))
    return moves, path


print("Running Efficiency Strategy on Current Ship")


eff_moves, eff_path = run_efficiency_on_ship(ship, max_time=30)

print(f"\nEfficiency Result: {eff_moves} moves")
if eff_path:
    print(f"Path length: {len(eff_path)}")
    print(f"First 10 moves: {eff_path[:10]}" if len(eff_path) > 10 else f"All moves: {eff_path}")

# Cell 4: Optimality Strategy for Any Ship Size

def optimality_strategy(ship, possible_bot_locations, max_states=50000, max_time=120):

    start_time = time.time()

    # Initial state: frozenset of all possible locations
    initial_state = frozenset(possible_bot_locations)

    print(f"Starting optimality search on {len(ship)}x{len(ship)} ship")
    print(f"Initial possible locations: {len(initial_state)}")

    # If already localized, return immediately
    if len(initial_state) == 1:
        print("Already localized!")
        return 0, []

    # Adaptive limits based on problem size
    if len(initial_state) > 30:
        print("Large state space - using aggressive limits")
        max_states = min(max_states, 100000)
        max_time = min(max_time, 300)

    # Priority queue: (f_score, g_score, state, path)
    open_set = PriorityQueue()
    open_set.put((0, 0, initial_state, []))

    # Visited states and their best g_scores
    g_scores = {initial_state: 0}
    visited = set()

    states_explored = 0
    best_solution = (float('inf'), [])  # (moves, path)
    best_state_size = len(initial_state)

    print("Progress: ● = 100 states explored")
    print(" ", end="")

    while not open_set.empty() and states_explored < max_states:
        current_time = time.time()
        if current_time - start_time > max_time:
            print(f"\nTimeout after {max_time} seconds")
            break

        f_score, g_score, current_state, path = open_set.get()

        # Skip if we've found a better path to this state
        if current_state in visited:
            continue

        visited.add(current_state)
        states_explored += 1

        # Progress indicator
        if states_explored % 100 == 0:
            print("●", end="", flush=True)
        if states_explored % 1000 == 0:
            print(f" [{states_explored}]", end="", flush=True)

        # Progress reporting
        if states_explored % 500 == 0:
            print(f"\n States: {states_explored}, Best: {best_solution[0]} moves, Locations: {best_state_size}")
            print(" ", end="")

        # Check if goal reached (single location)
        if len(current_state) == 1:
            print(f"Optimal solution found!")
            print(f"   Moves: {len(path)}")
            print(f"   States explored: {states_explored}")
            print(f"   Time: {current_time - start_time:.2f}s")
            return len(path), path

        # Keep track of best solution found so far
        if len(current_state) < best_state_size or (len(current_state) == best_state_size and len(path) < best_solution[0]):
            best_solution = (len(path), path)
            best_state_size = len(current_state)

        # Generate neighbors for all possible moves
        for move in ["UP", "DOWN", "LEFT", "RIGHT"]:
            new_state = apply_move_to_set(current_state, move, ship)

            # Skip if this move doesn't reduce uncertainty
            if len(new_state) >= len(current_state):
                continue

            new_g_score = g_score + 1
            new_path = path + [move]

            # Heuristic: minimum moves needed
            h_score = len(new_state) - 1

            if new_state not in g_scores or new_g_score < g_scores[new_state]:
                g_scores[new_state] = new_g_score
                f_score = new_g_score + h_score
                open_set.put((f_score, new_g_score, new_state, new_path))

    print(f"\nSearch completed")


    print(f"Total time: {time.time() - start_time:.3f}s")

    final_moves_opti.append((len(ship), best_solution[0], time.time() - start_time))
    return best_solution

def apply_move_to_set(position_set, move, ship_grid):
    """Apply a move to all positions in a set and return frozenset"""
    new_positions = set()
    for pos in position_set:
        new_pos = simulate_single_move(pos, move, ship_grid)
        new_positions.add(new_pos)
    return frozenset(new_positions)

def simulate_single_move(position, move, ship_grid):
    """Simulate a single move from a position"""
    x, y = position
    grid_size = len(ship_grid)

    if move == "UP" and x > 0 and ship_grid[x-1][y] == 0:
        return (x-1, y)
    elif move == "DOWN" and x < grid_size-1 and ship_grid[x+1][y] == 0:
        return (x+1, y)
    elif move == "LEFT" and y > 0 and ship_grid[x][y-1] == 0:
        return (x, y-1)
    elif move == "RIGHT" and y < grid_size-1 and ship_grid[x][y+1] == 0:
        return (x, y+1)
    else:
        return position  # Stay in place if move blocked

# to run opti strategy on ship
def run_optimality_on_ship(ship_grid, max_states=50000, max_time=120):

    # Get all possible locations from the ship
    possible_locations = []
    for i in range(len(ship_grid)):
        for j in range(len(ship_grid)):
            if ship_grid[i][j] == 0:
                possible_locations.append((i, j))

    print(f"Ship size: {len(ship_grid)}x{len(ship_grid)}")
    print(f"Open cells: {len(possible_locations)}")

    # Run optimality strategy
    moves, path = optimality_strategy(
        ship_grid,
        possible_locations,
        max_states=max_states,
        max_time=max_time
    )

    return moves, path


print("Running Optimality Strategy on Current Ship")



moves, path = run_optimality_on_ship(ship, max_states=50000, max_time=180)


if path:
    print(f"Path length: {len(path)}")
    print(f"First 10 moves: {path[:10]}" if len(path) > 10 else f"All moves: {path}")

#graph for optimality

final_moves_opti = []
final_moves_cowan = []
final_moves_effi = []

arr = [10, 12, 13, 15, 20, 30, 36, 41, 45, 50, 54, 57, 70, 73, 75, 90, 100]
iter_per_size = 10

for i in arr:
  for _ in range(iter_per_size):
    D, ship, deadends, open_cells = generate_ship(i)
    run_baseline_strat(ship)
    run_optimality_on_ship(ship, max_states=50000, max_time=180)
    run_efficiency_on_ship(ship, max_time=30)

pprint.pprint(final_moves_cowan)
pprint.pprint(final_moves_opti)
print(final_moves_effi)

final_temp_cowan = {}
final_temp_opti = {}
final_temp_effi = {}

for a,b,c in final_moves_cowan:
  final_temp_cowan.setdefault(a, []).append((b,c))

final_avg_cowan = []
for a, pairs in final_temp_cowan.items():
    avg_b = sum(p[0] for p in pairs) / len(pairs)
    avg_c = sum(p[1] for p in pairs) / len(pairs)
    final_avg_cowan.append((a, avg_b, avg_c))

for a,b,c in final_moves_opti:
  final_temp_opti.setdefault(a, []).append((b,c))

final_avg_opti = []
for a, pairs in final_temp_opti.items():
    avg_b = sum(p[0] for p in pairs) / len(pairs)
    avg_c = sum(p[1] for p in pairs) / len(pairs)
    final_avg_opti.append((a, avg_b, avg_c))

for a,b,c in final_moves_effi:
  final_temp_effi.setdefault(a, []).append((b,c))

final_avg_effi = []
for a, pairs in final_temp_effi.items():
    avg_b = sum(p[0] for p in pairs) / len(pairs)
    avg_c = sum(p[1] for p in pairs) / len(pairs)
    final_avg_effi.append((a, avg_b, avg_c))


print(final_avg_cowan)
print(final_avg_opti)
print(final_avg_effi)

import matplotlib.pyplot as plt

# Split into x and y
x1, y1_2, y1_3 = zip(*final_avg_cowan)
x2, y2_2, y2_3 = zip(*final_avg_opti)
x3, y3_2, y3_3 = zip(*final_avg_effi)

# Graph 1
plt.figure()
plt.plot(x1, y1_2, marker='o', label='Baseline')
plt.plot(x2, y2_2, marker='s', label='Optimality')
plt.xlabel('Size of ship')
plt.ylabel('Average number of moves to localize')
plt.title('Graph 1: Baseline vs Optimality')
plt.legend()
plt.grid(True)

# Graph 2
plt.figure()
plt.plot(x1, y1_2, marker='o', label='Baseline')
plt.plot(x3, y3_2, marker='s', label='Efficiency')
plt.xlabel('Size of ship')
plt.ylabel('Average number of moves to localize')
plt.title('Graph 2: Baseline vs Efficiency')
plt.legend()
plt.grid(True)

# Graph 3
plt.figure()
plt.plot(x1, y1_3, marker='o', label='Baseline')
plt.plot(x2, y2_3, marker='s', label='Optimality')
plt.plot(x3, y3_3, marker='^', label='Efficiency')
plt.xlabel('Size of ship')
plt.ylabel('Time taken to compute solution')
plt.title('Graph 3: Baseline vs Optimality vs Efficiency')
plt.legend()
plt.grid(True)

plt.show()

import time
import numpy as np
from collections import deque, defaultdict
import random
# Find hard starting sets for both strategies with robust error handling
def find_hard_starting_sets(ship, optimality_strategy_fn, efficiency_strategy_fn):


    print("Finding Hard Starting Sets")


    # Get all open cells
    open_cells = []
    for i in range(len(ship)):
        for j in range(len(ship)):
            if ship[i][j] == 0:
                open_cells.append((i, j))

    print(f"Total open cells: {len(open_cells)}")

    if len(open_cells) < 2:
        print("Not enough open cells to find hard sets")
        return [open_cells[0]], [open_cells[0]]

    # Find hard sets for both strategies
    hard_optimal_set = find_hard_optimal_set(ship, open_cells, optimality_strategy_fn)
    hard_efficiency_set = find_hard_efficiency_set(ship, open_cells, efficiency_strategy_fn)

    return hard_optimal_set, hard_efficiency_set

def find_hard_optimal_set(ship, open_cells, optimality_strategy_fn, max_iterations=100):





    fallback_set = [open_cells[0], open_cells[-1]]  # First and last open cells

    try:
        # Precompute all pairs shortest paths
        print("Computing all pairs shortest paths...")
        distance_matrix = compute_all_pairs_shortest_paths(ship, open_cells)

        # Find the diameter of the graph (maximum shortest path)
        max_distance = 0
        best_pairs = []

        for i, cell1 in enumerate(open_cells):
            for j, cell2 in enumerate(open_cells[i+1:], i+1):
                dist = distance_matrix[i][j]
                if dist > max_distance and dist < float('inf'):
                    max_distance = dist
                    best_pairs = [(cell1, cell2)]
                elif dist == max_distance and dist < float('inf'):
                    best_pairs.append((cell1, cell2))

        if not best_pairs:
            print("No connected pairs found, using fallback")
            return fallback_set

        print(f"Graph diameter: {max_distance}")
        print(f"Found {len(best_pairs)} pairs at maximum distance")

        # Test candidate sets and find the hardest one
        hardest_set = best_pairs[0]  # Start with first best pair
        max_moves = 0

        print("\nTesting candidate sets...")
        test_pairs = best_pairs[:min(5, len(best_pairs))]  # Test up to 5 pairs

        for i, (cell1, cell2) in enumerate(test_pairs):
            test_set = [cell1, cell2]
            print(f"Testing pair {i+1}: {test_set}")

            try:
                moves, _ = optimality_strategy_fn(ship, test_set, max_states=5000, max_time=10)
                print(f"  Required moves: {moves}")

                if moves > max_moves:
                    max_moves = moves
                    hardest_set = test_set
            except Exception as e:
                print(f"  Error testing set: {e}")
                continue

        # If we found a good set, return it
        if max_moves > 0:
            print(f"HARDEST OPTIMALITY SET FOUND:")
            print(f"   Set: {hardest_set}")
            print(f"   Size: {len(hardest_set)}")
            print(f"   Required moves: {max_moves}")
            return hardest_set

    except Exception as e:
        print(f"Error in optimal set search: {e}")

    # Fallback: return a simple pair
    print("Using fallback optimal set")
    return fallback_set

def find_hard_efficiency_set(ship, open_cells, efficiency_strategy_fn, max_iterations=50):

    print("FINDING HARD SET FOR EFFICIENCY STRATEGY")


    # Start with fallback
    fallback_set = open_cells[:3]  # First 3 open cells

    try:
        # Strategy 1: Find cells with identical neighbor patterns
        similar_sets = find_similar_pattern_cells(ship, open_cells)

        # Strategy 2: Find cells in open areas
        room_sets = find_room_cells(ship, open_cells)

        # Combine candidates, prioritize smaller sets first
        all_candidates = []

        # Add similar pattern sets (usually harder)
        for candidate in similar_sets:
            if 2 <= len(candidate) <= 6:
                all_candidates.append(candidate)

        # Add room sets
        for room in room_sets:
            if 3 <= len(room) <= 8:
                # Take a sample from the room
                sample_size = min(4, len(room))
                all_candidates.append(random.sample(room, sample_size))

        # Add some random sets as fallback
        for _ in range(3):
            if len(open_cells) >= 4:
                all_candidates.append(random.sample(open_cells, 4))

        if not all_candidates:
            print("No candidates found, using fallback")
            return fallback_set

        hardest_set = all_candidates[0]
        max_computation_time = 0
        max_moves = 0

        print("Testing candidate sets for efficiency strategy...")

        for i, candidate_set in enumerate(all_candidates[:10]):  # Test first 10
            print(f"Candidate {i+1}: size {len(candidate_set)}")

            try:
                start_time = time.time()
                moves, _ = efficiency_strategy_fn(ship, candidate_set)
                computation_time = time.time() - start_time

                print(f"  Moves: {moves}, Computation time: {computation_time:.2f}s")

                # Score based on computation time primarily
                if computation_time > max_computation_time:
                    max_computation_time = computation_time
                    max_moves = moves
                    hardest_set = candidate_set
            except Exception as e:
                print(f"  Error testing candidate: {e}")
                continue

        print(f"HARDEST EFFICIENCY SET FOUND:")
        print(f"   Set: {hardest_set}")
        print(f"   Size: {len(hardest_set)}")
        print(f"   Computation time: {max_computation_time:.2f}s")
        print(f"   Required moves: {max_moves}")

        return hardest_set

    except Exception as e:
        print(f"Error in efficiency set search: {e}")

    print("Using fallback efficiency set")
    return fallback_set
# Computing shortest path between all pairs of open cells using BFS
def compute_all_pairs_shortest_paths(ship, open_cells):

    n = len(open_cells)
    distance_matrix = [[float('inf')] * n for _ in range(n)]

    # Create mapping from coordinate to index
    cell_to_index = {cell: idx for idx, cell in enumerate(open_cells)}

    # BFS from each cell
    for start_idx, start_cell in enumerate(open_cells):
        distances = {start_cell: 0}
        queue = deque([start_cell])

        while queue:
            current = queue.popleft()
            current_dist = distances[current]
            x, y = current

            # Check all neighbors
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nx, ny = x + dx, y + dy
                neighbor = (nx, ny)
                if (0 <= nx < len(ship) and 0 <= ny < len(ship) and
                    ship[nx][ny] == 0 and neighbor not in distances):
                    distances[neighbor] = current_dist + 1
                    queue.append(neighbor)

        # Fill distance matrix
        for cell, dist in distances.items():
            if cell in cell_to_index:
                end_idx = cell_to_index[cell]
                distance_matrix[start_idx][end_idx] = dist
                distance_matrix[end_idx][start_idx] = dist  # Symmetric

    return distance_matrix
#Finding cells that have similar movement characteristics
def find_similar_pattern_cells(ship, open_cells):

    similar_sets = []

    # Group cells by their neighbor pattern (which directions are open)
    neighbor_patterns = defaultdict(list)

    for cell in open_cells:
        x, y = cell
        pattern = []

        # Check all four directions
        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(ship) and 0 <= ny < len(ship) and ship[nx][ny] == 0:
                pattern.append(1)
            else:
                pattern.append(0)

        # Convert pattern to hashable tuple
        pattern_tuple = tuple(pattern)
        neighbor_patterns[pattern_tuple].append(cell)

    # Add sets with identical patterns (these are hard to distinguish)
    for pattern, cells in neighbor_patterns.items():
        if len(cells) >= 2:
            similar_sets.append(cells)
            print(f"Found {len(cells)} cells with pattern {pattern}")

    return similar_sets

def find_room_cells(ship, open_cells, min_room_size=3):
    """Identify cells that are part of open areas"""
    visited = set()
    rooms = []

    for cell in open_cells:
        if cell not in visited:
            # BFS to find connected component
            room = []
            queue = deque([cell])
            visited.add(cell)

            while queue:
                current = queue.popleft()
                room.append(current)
                x, y = current

                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                    nx, ny = x + dx, y + dy
                    neighbor = (nx, ny)
                    if (0 <= nx < len(ship) and 0 <= ny < len(ship) and
                        ship[nx][ny] == 0 and neighbor not in visited):
                        visited.add(neighbor)
                        queue.append(neighbor)

            if len(room) >= min_room_size:
                rooms.append(room)
                print(f"Found room with {len(room)} cells")

    return rooms

def analyze_hardness_patterns(hard_optimal, hard_efficiency, ship):


    print(f"\nOptimal Strategy Hard Set: {hard_optimal}")
    print(f"Efficiency Strategy Hard Set: {hard_efficiency}")

    print(" ANALYSIS:")

    # Analyze optimal strategy hardness
    if len(hard_optimal) == 2:
        cell1, cell2 = hard_optimal
        manhattan_dist = abs(cell1[0]-cell2[0]) + abs(cell1[1]-cell2[1])
        print(f"• Optimal hardness: MAXIMUM DISTANCE")
        print(f"  - Cells are {manhattan_dist} Manhattan distance apart")
        print(f"  - Strategy must reconcile two extreme possibilities")
    else:
        print(f"• Optimal hardness: MULTIPLE DISPERSED POINTS")
        print(f"  - {len(hard_optimal)} widely separated locations")
        print(f"  - Complex uncertainty resolution required")

    # Analyze efficiency strategy hardness
    if len(hard_efficiency) >= 4:
        print(f"• Efficiency hardness: SYMMETRIC/AMBIGUOUS REGION")
        print(f"  - Large set of {len(hard_efficiency)} similar cells")
        print(f"  - Greedy strategy confused by multiple good options")
    else:
        # Check if cells have similar patterns
        patterns = set()
        for cell in hard_efficiency:
            x, y = cell
            pattern = tuple(1 if (0 <= x+dx < len(ship) and 0 <= y+dy < len(ship) and ship[x+dx][y+dy] == 0) else 0
                          for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)])
            patterns.add(pattern)

        if len(patterns) == 1:
            print(f"• Efficiency hardness: IDENTICAL PATTERN CELLS")
            print(f"  - All {len(hard_efficiency)} cells have same movement options")
            print(f"  - Impossible to distinguish with single moves")
        else:
            print(f"• Efficiency hardness: SIMILAR CHARACTERISTICS")
            print(f"  - {len(hard_efficiency)} cells with similar properties")
            print(f"  - Causes hesitation in greedy decision-making")


    print("1. OPTIMAL STRATEGY: Hardness = Long distances between possibilities")
    print("2. EFFICIENCY STRATEGY: Hardness = Symmetry and ambiguity")
    print("3. EASY CASES: Unique features, dead ends, asymmetric layouts")
    print("4. HARD CASES: Symmetric regions, central locations, similar patterns")

# Test the fixed implementation
if __name__ == "__main__":
    try:
        hard_optimal, hard_efficiency = find_hard_starting_sets(
            ship,
            optimality_strategy,  # Your optimality strategy function
            efficiency_strategy   # Your efficiency strategy function
        )

        # Analyze the patterns
        analyze_hardness_patterns(hard_optimal, hard_efficiency, ship)

    except Exception as e:
        print(f"Error in main execution: {e}")
        print("Creating simple fallback sets...")
        # Create simple fallback sets
        open_cells = [(i, j) for i in range(len(ship)) for j in range(len(ship)) if ship[i][j] == 0]
        if len(open_cells) >= 2:
            hard_optimal = [open_cells[0], open_cells[-1]]
            hard_efficiency = open_cells[:min(4, len(open_cells))]
            print(f"Fallback optimal set: {hard_optimal}")
            print(f"Fallback efficiency set: {hard_efficiency}")